# Integration & Abstraction Patterns

## グループ概要

**Integration & Abstraction Patterns** は、LLM システムを外部サービス・複数ベンダー・既存業務基盤と連携させる際に、依存を最小化しつつ拡張性・再利用性を高める設計手法です。疎結合アーキテクチャと明確な境界の抽象化により、変更に強く長期運用しやすい統合レイヤを構築します。

### 主なユースケース
| ユースケース | 目的 | 代表パターン |
|--------------|------|--------------|
| マルチベンダー LLM 切替 | プロバイダ依存排除・SLA 最適化 | OpenAI Gateway / Inference Abstract Factory |
| 既存 DDD ドメインへの LLM 統合 | ドメイン境界を守りつつ AI 活用 | Domain‑Oriented Prompt Design |
| マイクロサービス間の共通 LLM SDK | インターフェース肥大化を防止 | LLM Service Interface Segregation |
| 複雑ワークフローの可読性向上 | 手続き的処理を責務分離 | Prompt Command / Chain of Responsibility |

---

## パターン詳細

### 1. LLM Service Interface Segregation Pattern
| 項目 | 内容 |
|------|------|
| **説明** | ISP (Interface Segregation Principle) を適用し、タスクごとに最小限メソッドを持つ複数の小インターフェースへ分割。 |
| **用途** | マイクロサービスが必要な機能だけ注入してテスト容易化。 |
| **解決課題** | "God" クライアント SDK で変更影響が波及。 |
| **対象システム** | 多機能 SaaS、社内共通 LLM SDK。 |
| **メリット** | 疎結合、モック容易、望まぬ依存回避。 |
| **注意点** | インターフェース乱立による管理コスト。 |

---

### 2. OpenAI Gateway Pattern
| 項目 | 内容 |
|------|------|
| **説明** | API Gateway 層で OpenAI 呼び出しを一元集約し、認証・レート制御・監査を実装。 |
| **用途** | 社内外アプリからの共通 OpenAI アクセス。 |
| **解決課題** | 各サービスが個別にキー管理・レート制御する負担。 |
| **対象システム** | エンタープライズ多サービス統合。 |
| **メリット** | セキュリティ統制・キャッシュ共有・コスト可視化。 |
| **注意点** | ゲートウェイ単一障害点、スケール設計必須。 |

---

### 3. Domain‑Oriented Prompt Design Pattern
| 項目 | 内容 |
|------|------|
| **説明** | DDD のバウンデッドコンテキストごとにプロンプトテンプレートと語彙 (Ubiquitous Language) を定義。 |
| **用途** | 業務ドメイン知識を LLM に正確伝達。 |
| **解決課題** | 汎用プロンプトでドメイン語が曖昧化し精度低下。 |
| **対象システム** | ERP、金融リスク解析、医療診断支援。 |
| **メリット** | 一貫性・メンテ容易、チーム間協調。 |
| **注意点** | ドメインモデル変更時テンプレ更新の同期。 |

---

### 4. Inference Abstract Factory Pattern
| 項目 | 内容 |
|------|------|
| **説明** | 生成・分類・要約など推論タイプ別に抽象ファクトリを定義し、モデル選択とデフォルトパラメータをカプセル化。 |
| **用途** | タイプ別に最適モデルを切替。 |
| **解決課題** | if/else で推論タイプをハードコーディング。 |
| **対象システム** | AI ユーティリティ SDK、AutoML パイプライン。 |
| **メリット** | 拡張容易、ベンダーロック緩和。 |
| **注意点** | ファクトリ肥大化に留意 (Abstract Factory + Builder 併用推奨)。 |

---

### 5. Prompt Command Pattern
| 項目 | 内容 |
|------|------|
| **説明** | Command パターンで各プロンプト生成・送信をオブジェクト化し、キューイングやアンドゥ/リトライを付与。 |
| **用途** | 連続操作ワークフロー、履歴管理。 |
| **解決課題** | 手続き的 API 呼び出しでトランザクション性が欠如。 |
| **対象システム** | ドキュメント編集 AI、RPA 組込。 |
| **メリット** | コマンド再実行・操作ログ容易。 |
| **注意点** | コマンド粒度設計が成功の鍵。 |

---

### 6. Prompt Chain of Responsibility Pattern
| 項目 | 内容 |
|------|------|
| **説明** | 複数のプロンプト処理ハンドラをチェーン接続し、条件に応じて責務を委譲。 |
| **用途** | 前処理→LLM→後処理→検証 のステージ構成。 |
| **解決課題** | 大きな関数で前後処理を詰め込み可読性悪化。 |
| **対象システム** | 監査コンプライアンス付き生成パイプライン。 |
| **メリット** | 拡張性・固有ロジック分離・再利用。 |
| **注意点** | ループ・順序依存バグが潜みやすい。

---

## アンチパターン

### 1. Unified Monolith Adapter（巨大一枚岩アダプタ）
- **概要**: あらゆる API 仕様を 1 つのモンスタークラスに詰め込み、変更が連鎖的に破壊。
- **問題点**: 高凝集・低内聚、テスト不能。
- **事例**: 2,000 行超の Adapter が新モデル追加で崩壊。

### 2. Leaky Abstraction Pattern（漏れた抽象化）
- **概要**: 抽象レイヤが内部実装の詳細 (パラメータ名、リトライ戦略) を外側に露出。
- **問題点**: 上位層が下位変更に敏感で破壊的互換影響。
- **事例**: Gateway 内部の rate_limit_ms を複数サービスが参照、値変更で障害多発。
