# Declarative Composition & Execution Pattern

## 概要

Declarative Composition & Execution Patternは、LLMや外部サービスとの連携処理を「宣言的」に定義し、実行エンジンがその定義に従って処理フローを構築・実行する設計手法です。プロンプト構成、分岐、ループ、条件処理などをYAMLやDSLなどの形式で記述することで、再利用性や可読性の高いワークフローを構築することができます。

## 解決したい課題

LLMを組み込んだシステム開発では、以下のような課題が頻発します。

1. **処理フローのスパゲッティ化**
   - 各ステップ（プロンプト生成、LLM呼び出し、ポストプロセス）がコード上で複雑に絡み合い、保守が困難になります。
   - 例：プロンプトの生成、LLMの呼び出し、結果の後処理が一つの関数に混在し、変更が困難になります。

2. **変更コストの増大**
   - 処理ステップの追加や順序変更、条件分岐の調整のたびにコード全体を変更する必要があり、バグリスクが高まります。
   - 例：新しいプロンプトテンプレートを追加する際に、既存のコードを大幅に修正する必要があります。

3. **再利用・共有の困難さ**
   - 手続き型で記述されたフローは他プロジェクトへの移植性が低く、ノウハウの共有も難しくなります。
   - 例：あるプロジェクトで成功したプロンプトチェーンを他のプロジェクトで再利用する際に、コードの書き換えが必要になります。

4. **実行状況の可視化不足**
   - ステップごとの実行結果や失敗ポイントの特定が困難で、障害対応に時間を要します。
   - 例：LLMの応答が期待通りでない場合、どのステップで問題が発生したのか特定が困難です。

## 解決策

このパターンでは、フロー定義をYAMLや独自DSL形式で記述し、以下の構成要素を組み合わせて実現します。

1. **宣言的定義ファイル**
   - 各ステップの種類（プロンプト、LLM呼び出し、分岐、ループなど）とパラメータを記述します。
   - 例：YAMLファイルでプロンプトのテンプレート、条件分岐、ループ処理を定義します。

2. **コンポーネントカタログ**
   - LLM呼び出し、外部サービス連携、フォーマット変換などの機能をステップ単位でモジュール化します。
   - 例：共通のプロンプト生成、翻訳、要約などの機能を再利用可能なコンポーネントとして提供します。

3. **実行エンジン**
   - 定義ファイルを読み込み、依存関係の解決、状態管理、ログ記録、リトライ制御などを自動で実行します。
   - 例：YAML定義を読み込み、各ステップを順次実行し、結果を次のステップに渡します。

## 適応するシーン

このパターンは以下のようなシステムで有効に活用できます。

- ドキュメント生成プラットフォーム（例：データ取得→要約→翻訳→フォーマット）
- 動的RAGワークフロー（例：検索→スコアリング→要約→再検索）
- 対話型エージェント（例：権限による分岐、ループ対応）
- バッチ処理パイプライン（例：ファイル分割→並列処理→集約）

## 利用するメリット

このパターンを活用することで、以下の利点が得られます。

- **可読性・保守性の向上**：構造化された定義により、フロー全体の理解がしやすくなります。
- **変更の容易さ**：処理ステップの追加・削除・変更がコード修正なしで可能になります。
- **再利用・共有性**：フロー定義をテンプレート化することで、プロジェクト間での共有が促進されます。
- **モニタリング・可視化の容易さ**：各ステップの実行ログを収集し、障害発生箇所の特定が容易になります。

## 注意点とトレードオフ

このパターンの導入には以下の注意点があります。

- **初期導入コストの高さ**：宣言的定義ファイルとそれを処理する実行エンジンの設計・実装が必要です。
- **実行性能の低下**：インタプリタ型実行となるため、ネイティブコードよりオーバーヘッドが発生します。
- **学習曲線の存在**：チーム全体がDSLやYAMLの文法、実行エンジンの挙動に習熟する必要があります。
- **ベンダーロックインの可能性**：特定エンジンに依存したDSLを採用すると、将来的な乗り換えが難しくなります。

## 導入のヒント

このパターンを導入する際は、以下のような工夫が有効です。

1. **小規模なPoCから開始する**：まずは3〜5ステップのワークフローから試行し、効果を確認します。
2. **再利用可能なステップのライブラリ化**：共通処理（LLM呼び出し、翻訳、整形処理など）をコンポーネントとして整理します。
3. **エディタとバリデーションの提供**：YAML/DSLのプレビューやスキーマチェックが可能なUIを整備します。
4. **CI/CD統合**：フロー定義の変更をGitで管理し、構文チェックやテストを自動化します。
5. **ガバナンスルールの明文化**：エラー時の挙動（リトライ回数、フォールバック処理）をあらかじめ定義しておきます。

## まとめ

Declarative Composition & Execution Patternは、LLMや外部サービスとの連携フローを宣言的に記述することで、柔軟で再利用性の高いワークフロー設計を実現するパターンです。可読性や変更の容易さ、障害対応の効率化といった利点がある一方で、初期構築やチーム教育には一定のコストが伴います。段階的な導入と仕組み化を進めることで、大規模な生成AIシステムの開発・運用を支える中核的な基盤となります。
