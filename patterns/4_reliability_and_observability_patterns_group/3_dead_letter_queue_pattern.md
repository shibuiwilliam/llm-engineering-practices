# Dead Letter Queue Pattern

## 説明  
Dead Letter Queue (DLQ) Pattern は、LLM 呼び出しやメッセージ駆動ワークフロー中に「処理に失敗したメッセージやリクエスト」を別キュー（DLQ）に移動し、通常フローから切り離して後続の分析／再処理を可能にする設計手法です。  
- **メインキュー**：通常のリクエストやイベントを処理  
- **DLQ**：一定回数以上のリトライ失敗や致命的エラー発生時にメインキューから移送  
- **コンシューマ**：DLQ 専用のワーカーやオペレーションチームがログ・原因解析 → 再投入 or 廃棄

## 用途  
- **バッチ要約パイプライン**：モデル呼び出しエラーやフォーマット不正ドキュメントを DLQ へ隔離  
- **チャットメッセージ処理**：不正リクエストや API レート制限超過を DLQ でキャプチャし、後で別フロー検証  
- **イベントドリブンワークフロー**：Webhook／Kafka メッセージで処理不能エラーが起きた場合に DLQ へ退避  
- **多段階 RAG パイプライン**：検索→要約→出力の各ステップで異常時に該当メッセージを DLQ に移動

## 解決する課題  
1. **無限リトライループ**  
   - 失敗し続けるメッセージでワーカーが延々と再試行し、他メッセージ処理が滞る  
2. **障害波及防止**  
   - 一部データ／リクエストの問題でパイプライン全体が停止するリスクを回避  
3. **原因追跡困難**  
   - ログだけではどのメッセージが何回・なぜ失敗したか把握しづらい  
4. **運用負荷増大**  
   - 障害発生時の全ジョブ再実行や個別デバッグ工数を削減

## 対象とするシステム／プロジェクト  
- **マイクロサービスアーキテクチャ**：サービス間メッセージングで異常メッセージを隔離  
- **大規模バッチ処理**：数十万件のドキュメントを要約/分類するジョブパイプライン  
- **リアルタイムチャットプラットフォーム**：高頻度メッセージ処理中のエラー隔離  
- **IoT データ処理**：センサーデータ解析でフォーマット不正や値異常を後処理キューへ隔離

## 利用するメリット  
- **システム安定性向上**  
  - 処理不能メッセージを隔離し、健全なリクエストは継続処理  
- **障害対応効率化**  
  - DLQ に溜まったメッセージだけを対象に原因解析および再処理を実施  
- **可観測性強化**  
  - 失敗・隔離されたメッセージ数やエラー理由をメトリクス化し、傾向分析が可能  
- **データ品質保証**  
  - 異常データを流入前に特定し、データクレンジングやバリデーション強化に活用

## 注意点とトレードオフ  
- **キュー管理コスト**  
  - DLQ のストレージ増大やライフサイクル管理（古いメッセージの削除や保存ポリシー）が必要  
- **遅延発生**  
  - 隔離メッセージの再投入フローを設けないと、後続処理までの遅延が発生  
- **運用プロセス整備**  
  - DLQ 処理責任者や SLA、再処理手順をドキュメント化しないと放置リスク  
- **再投入の副作用**  
  - 原因修正前に再投入すると再度失敗し、無限ループ化する恐れ

## 導入のヒント  
1. **リトライポリシー設計**  
   - メインキューでの最大リトライ回数や指数バックオフ設定を明確化  
2. **DLQ メタデータ付与**  
   - エラーコード、リトライ回数、最終失敗時刻をメッセージ属性に含め、解析を容易に  
3. **定期バッチ処理**  
   - 定期的に DLQ をスキャンし、原因別に再処理 or アラートを自動化  
4. **監視とアラート**  
   - DLQ の長さや流入率を Prometheus/Grafana で可視化し、閾値超過時に通知  
5. **自動再投入フロー**  
   - エラー原因が一時的（API レート制限など）と判定された場合のみ自動リトライできる仕組みを構築  
