# Idempotent Inference Request Pattern

## 説明  
Idempotent Inference Request Pattern は、同一のプロンプトリクエストを**複数回送信しても結果とシステム状態に副作用が生じない**よう設計する手法です。  
- **リクエスト識別子**：プロンプト内容やユーザコンテキストのハッシュ値、UUID を用いて一意キーを生成  
- **キャッシュ／デデュープ層**：同一キーのリクエストは最初の応答を再利用し、LLM 呼び出しを省略  
- **再試行安全性**：ネットワーク障害やタイムアウト後のリトライで余分なコスト発生や不整合を防止  
- **副作用管理**：プロンプト生成、ログ記録、外部サービス連携などが複数回実行されない設計

## 用途  
- **ユーザインタラクション**：UI レベルでの再送信防止（複数クリック、ページリロード）  
- **分散システム**：マイクロサービス間のネットワーク障害後に一貫した推論結果を提供  
- **バッチ処理ジョブ**：大量ドキュメント処理時の再実行で、同一ドキュメントを重複処理しない  
- **イベント駆動ワークフロー**：メッセージブローカー再配信による重複イベントを安全にハンドリング  

## 解決する課題  
1. **不確実な再試行コスト**  
   - リトライごとに新規呼び出しとなり、トークン消費やレート制限を浪費  
2. **一貫性の欠如**  
   - 同一プロンプトでもモデルの非決定性で応答が毎回異なり、上流ロジックが混乱  
3. **重複処理による副作用**  
   - ログ登録や外部 API 呼び出しが重複実行され、データ不整合を招く  
4. **運用トラブル**  
   - 障害復旧後にジョブがダブって実行され、予期せぬコストやパフォーマンス低下

## 対象とするシステム／プロジェクト  
- **セルフサービスチャットボット**：通信途絶→再接続後も同じ回答を返し、ユーザ混乱を防止  
- **RAG バッチパイプライン**：ドキュメント毎に一度だけ要約・分類タスクを実行  
- **イベント駆動マイクロサービス**：重複シグナル発行時の LLM 呼び出しを一度に限定  
- **モバイルアプリ連携**：接続リトライ時の同一質問で一貫したレスポンスを維持

## 利用するメリット  
- **再試行安全性**：ネットワーク障害や UI 操作ミスによる二重呼び出しが無害化  
- **コストコントロール**：同一リクエストはキャッシュで応答し、無駄なトークン消費を削減  
- **一貫性保証**：結果のばらつきを抑え、上流ロジックやユーザ体験を安定化  
- **副作用排除**：外部連携やログ記録が一度だけ実行され、データ整合性を保つ

## 注意点とトレードオフ  
- **キャッシュ管理コスト**  
  - 一意キー→応答キャッシュの保存・期限管理が必要で、ストレージ負荷が増加  
- **非決定性モデルとの相性**  
  - LLM のランダムシードや温度設定によりキャッシュ効かないケースがあり得る  
- **TTL（有効期限）の設計**  
  - 長期保存で古い結果を返すリスク、短期 TTL でリトライ許容度が下がるトレードオフ  
- **設計複雑度**  
  - リクエストキー生成ロジックやデデュープ層を含むアーキテクチャが複雑化

## 導入のヒント  
1. **キー戦略の決定**  
   - プロンプト文字列ハッシュ＋ユーザ ID／タイムスタンプなど、適切な一意性を確保  
2. **キャッシュレイヤの採用**  
   - Redis や Memcached で高速キャッシュし、TTL やメモリ制限を設定  
3. **モデル設定の固定化**  
   - 温度・シード値を固定し、真の idempotency を実現  
4. **フォールバック設計**  
   - キャッシュミス時のみ新規呼び出し、障害時は控えめなデフォルト応答を返却  
5. **モニタリングとアラート**  
   - キャッシュヒット率、二重呼び出し件数、エラー率を可視化し、異常を検知  
