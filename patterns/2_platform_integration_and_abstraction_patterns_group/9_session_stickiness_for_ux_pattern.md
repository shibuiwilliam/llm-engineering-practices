# Session Stickiness for UX Pattern

## 説明  
Session Stickiness for UX Pattern は、ユーザの「セッション」（対話 ID、ユーザ ID、ブラウザセッションなど）に紐づくリクエストを、常に同じモデルコンテキストまたは同じバックエンドインスタンスにルーティングし続ける設計手法です。  
- **セッション識別子**（Cookie、JWT、カスタムヘッダなど）を用いてユーザ／会話コンテキストを一意に管理  
- **ロードバランサ／API ゲートウェイ**で同一セッションのリクエストを同じノードへ誘導  
- **状態保持**：会話履歴やパーソナライズ情報をインメモリまたはセッションストアにキャッシュ  

## 用途  
- **マルチターンチャットボット**：会話履歴を同一ノードで継続保持し、文脈切れを防ぐ  
- **パーソナライズド対話**：ユーザ毎のモデルチューニングやメモリをインスタンスローカルに蓄積  
- **Webアプリケーション**：入力アシストやサジェスト機能で、一貫した UX を提供  
- **モバイルクライアント**：断続的ネットワークでの再接続時にも同一バックエンドに接続  

## 解決する課題  
1. **文脈消失**  
   - 別ノードにルーティングされるとインメモリの履歴が参照できず会話が途切れる  
2. **応答の不整合**  
   - 同じユーザでもノード毎に異なるキャッシュ・モデル設定で返答品質がばらつく  
3. **パーソナライズ維持困難**  
   - 個別チューニングや履歴ベースのレコメンデーションが分散環境で実現しづらい  
4. **ユーザ体験の断絶**  
   - タイプ中にノード再接続で待ち時間やプロンプト重複が発生  

## 対象とするシステム／プロジェクト  
- **エンタープライズチャット基盤**：社内外ユーザ向けマルチターンダイアログ  
- **カスタマーサポート BOT**：連続する問い合わせセッションで文脈を保つ  
- **教育対話プラットフォーム**：個別学習履歴を問答ごとに維持  
- **パーソナライズドアシスタント**：ユーザ設定や過去対話をローカルキャッシュ  

## 利用するメリット  
- **文脈一貫性**：会話履歴や設定を継続的に利用し、UX の中断を防止  
- **高速応答**：インメモリキャッシュへのアクセス頻度を高め、レイテンシを低減  
- **パーソナライズ強化**：同一インスタンスに状態を集約し、ユーザ固有情報を活用  
- **運用シンプル化**：状態同期の複雑な分散設計を回避し、個別ノードで完結  

## 注意点とトレードオフ  
- **ロードバランス効率低下**  
  - セッション拘束により一部ノードに負荷が偏る可能性  
- **単一障害点のリスク**  
  - スティッキーに紐づくノードが落ちるとセッションがリセットされる恐れ  
- **スケーリング制約**  
  - ノード追加時に既存セッションの再アフィニティ計画が必要  
- **ステート管理コスト**  
  - セッションストアの容量・整合性・TTL 管理が増加  

## 導入のヒント  
1. **セッション識別設計**  
   - 安全なトークン（JWT等）を用い、ロードバランサ／API ゲートウェイで一貫認識  
2. **インメモリ vs 分散キャッシュ**  
   - 小規模: 各ノード内メモリキャッシュ、 大規模: Redis/GCP Memorystore などで全ノード共有  
3. **フェイルオーバーハンドリング**  
   - ノード障害時はセッションストアから新ノードにコンテキストをリカバリ  
4. **負荷分散ポリシー**  
   - セッション数閾値を監視し、スケールアウト／新ノード登録でバランス調整  
5. **モニタリング**  
   - セッションステイキーレート、ノード当たりセッション数、エラー時の再接続率を可視化  
