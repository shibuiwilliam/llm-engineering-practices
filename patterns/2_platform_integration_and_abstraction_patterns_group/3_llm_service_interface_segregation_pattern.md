# LLM Service Interface Segregation Pattern

## 説明  
LLM Service Interface Segregation Pattern は、LLM（大規模言語モデル）関連機能を提供するサービス層の API を「責務ごとに細かく分割」し、それぞれ専用のインターフェースとして定義する設計手法です。  
- **Interface Segregation Principle (ISP)** に基づき、必要最小限のメソッド群を小さなインターフェースにまとめる  
- **例**  
  - `ITextGenerationService.generate(prompt, options)`  
  - `IEmbeddingService.embed(text)`  
  - `IChatConversationService.sendMessage(sessionId, message)`  
  - `IFunctionInvokeService.call(functionName, args)`  
- 各インターフェースは実装依存せずにビジネスロジックから参照・モック可能

## 用途  
- **複数ユースケース共存**：テキスト生成、要約、翻訳、埋め込み取得、ツール呼び出しなど、用途別に API を分離  
- **マイクロサービス／モジュール化**：サービスとして独立デプロイ可能なコンポーネント単位で責務を切り出し  
- **テスト容易化**：不要なメソッドを含まない細粒度インターフェースをモック化し、ユニットテストを高速化  
- **権限管理**：機能ごとに異なる認可設定やレート制限を適用しやすくする  

## 解決する課題  
1. **巨大インターフェースの肥大化**  
   - すべての LLM 操作を一つの `ILLMService` に詰め込むと、使わない機能まで依存してしまう  
2. **テスト難易度の増大**  
   - 不要なメソッドを持つモックを用意すると、テストが複雑化しメンテナンスコストが上がる  
3. **責務混在による変更影響範囲の拡大**  
   - 新機能追加時に既存インターフェースを拡張すると、利用箇所すべての再ビルド／テストが必要  
4. **認可／レート制御の一元化困難**  
   - 機能別に異なるポリシーを当てたいときに、単一インターフェースでは細かい制御がしづらい  

## 対象とするシステム／プロジェクト  
- **エンタープライズ向けチャット基盤**：会話、生成、サマリ、RAG、ツール呼び出しなど多彩な機能を提供  
- **モジュール化された AI プラットフォーム**：各機能を独立サービスとして構築し、チーム横断で開発  
- **マイクロサービスアーキテクチャ**：LLM 関連機能をそれぞれ独立デプロイし、スケールを最適化  
- **マルチテナント SaaS**：テナント毎に利用可能な機能セットを細かく分けて権限管理  

## 利用するメリット  
- **疎結合かつ明確な責務分離**  
  - 各機能インターフェースは必要なメソッドだけを定義し、依存関係を最小化  
- **テスト・モックの簡素化**  
  - 小粒度インターフェースはモック実装が薄く、テストのセットアップ時間を短縮  
- **安全な拡張性**  
  - 新しい機能追加は新インターフェースとして切り出すため、既存コードに影響を与えない  
- **認可・レート制御の柔軟化**  
  - 機能単位で異なるポリシー（RBAC、レート制限）を適用しやすい  

## 注意点とトレードオフ  
- **インターフェース数の増加**  
  - あまりに細かく分けすぎると、実装クラスや DI コンテナの設定が煩雑化  
- **設計コスト**  
  - 初期段階でどの粒度に切り分けるか判断を誤ると、後から統合や再分割が必要  
- **依存関係管理**  
  - 複数インターフェースをまとめて利用するクライアント実装では、インターフェース注入が多くなる  
- **ドキュメント負荷**  
  - 小粒度インターフェースが増えることで、API ドキュメントの整備・共有コストが増大  

## 導入のヒント  
1. **機能マッピングから開始**  
   - 主要ユースケース（生成・埋め込み・チャット・ツール呼び出し）ごとに必要メソッドをリストアップ  
2. **段階的リファクタリング**  
   - 既存の大規模インターフェースを少しずつ分割し、テスト範囲を保ちながら移行  
3. **DI コンテナ活用**  
   - Spring, Guice, NestJS などの DI フレームワークを用いて、機能インターフェースをキーに注入  
4. **ポリシー統合**  
   - 各インターフェースに対して認可・レート制御ミドルウェアを挟み、一貫した運用基盤を構築  
5. **ドキュメント＆サンプルコード**  
   - 機能別インターフェースのサンプル利用コードを整備し、新規チームメンバーの理解を促進  
