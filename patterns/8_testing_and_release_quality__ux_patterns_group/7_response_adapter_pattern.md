# Response Adapter Pattern

## 説明  
Response Adapter Pattern は、LLM や他コンポーネントから返された生レスポンスを、アプリケーション固有のデータ構造や UI 表示フォーマットへ**一貫して変換**する「アダプタ層」を設ける設計手法です。これにより、バックエンドやモデルが進化しても前段のビジネスロジックやフロントエンドへの影響を最小限に抑えられます。  
- **変換ルール定義**：生レスポンスフィールド→ドメインオブジェクト／DTO のマッピングを明示  
- **アダプタコンポーネント**：`ResponseAdapter` クラス群が各レスポンスタイプを受け取り変換  
- **プラグイン可能**：モデルごと、エンドポイントごとに異なるアダプタを実装・差し替え可能  
- **共通インターフェース**：`IResponseAdapter<TIn,TOut>` などジェネリックインターフェースで抽象  

## 用途  
- **UI バインディング**：LLM の JSON/文字列出力を Web UI の ViewModel や React Props に整形  
- **API ゲートウェイ**：内部マイクロサービスの生データを外部 API 仕様に合わせて再構築  
- **エラーハンドリング標準化**：標準エラー形式（コード＋メッセージ）にマッピングし、統一的に処理  
- **多モデル併用**：異なるモデルプロバイダからのレスポンスを統一的なドメイン型へアダプト  

## 解決する課題  
1. **レスポンス仕様依存**  
   - モデルやバックエンドのアップデートで生レスポンス構造が変わると、全コード修正が必要  
2. **ビジネスロジック汚染**  
   - 直接 JSON パースや文字列操作をビジネス層／UI 層で行うと可読性・保守性が低下  
3. **エラー処理バラツキ**  
   - 様々なエラー構造を呼び出し箇所ごとにハンドリングすると統制が困難  
4. **テスト困難**  
   - 生レスポンス直結だと出力変化に対する単体テストが書きづらい  

## 対象とするシステム／プロジェクト  
- **多モデルチャットボット**：OpenAI, Anthropic, OSS モデルそれぞれのメタデータ・フォーマットを統一  
- **データ探索 UI**：RAG 検索結果→カードコンポーネントへのマッピングを一元化  
- **エンタープライズ API**：複数内部マイクロサービスの呼び出し結果を単一 API レスポンスへ集約  
- **モバイルアプリ**：Token ストリーム→プログレスバーや逐次描画用オブジェクトへ変換  

## 利用するメリット  
- **疎結合化**：ビジネス／UI ロジックは `adapter.adapt(response)` 呼び出しだけを意識  
- **変更耐性**：生レスポンス構造が変わってもアダプタ層のみ修正すれば上位影響を回避  
- **テスト容易性**：アダプタ単体に対して入力→出力のユニットテストを集中できる  
- **一貫したエラーハンドリング**：アダプタで正常系・異常系を統一スキーマへ整形  

## 注意点とトレードオフ  
- **追加レイヤーのオーバーヘッド**  
  - 変換コードの分だけ呼び出しチェーンが増え、若干のレイテンシ上昇  
- **アダプタ数増加**  
  - 多様なエンドポイント／モデル分だけアダプタ実装が必要で管理が煩雑化  
- **設計コスト**  
  - 初期スキーマ設計とインターフェース定義工数が発生  
- **過度な抽象化リスク**  
  - シンプルなシステムで無闇にアダプタ化すると過剰設計になり得る  

## 導入のヒント  
1. **ジェネリックインターフェース定義**  
   - `IResponseAdapter<TIn, TOut>` を用意し、実装を簡素化  
2. **ベースアダプタ抽出**  
   - 共通変換ロジック（例：日付フォーマット、メタデータ抽出）は基底クラスにまとめる  
3. **DI コンテナ連携**  
   - Spring/Guice/TS DI によるアダプタ自動解決で呼び出し側コードを簡潔化  
4. **スキーマ駆動テスト**  
   - レスポンススキーマ定義とサンプル JSON を元に、自動テストケースを生成  
5. **段階的適用**  
   - まずはエラー系・共通フィールドからアダプタ化し、徐々に正常系へのマッピングを拡充  
