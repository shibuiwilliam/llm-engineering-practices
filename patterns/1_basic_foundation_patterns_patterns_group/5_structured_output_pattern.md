# Structured Output Pattern

## 説明
Structured Output Pattern は、LLM の出力を自由なテキストではなく、あらかじめ定義した構造化データ形式（JSON, YAML, Protobuf, Pydantic モデルなど）で返却させる設計手法です。  
- **Function Calling／JSON Mode** を利用し、モデルにスキーマを渡して出力を強制  
- 出力フォーマットを厳密に定義し、パーサーやスキーマバリデーションで受信  

## 用途
- データベース登録用のフィールド抽出（例：商品情報、住所、ユーザ属性）  
- フォーム自動入力・文書解析パイプライン  
- レポートやダッシュボード生成のためのメトリクス抽出  
- ツール／API 呼び出しパラメータ生成（LLM をコントロールするマイクロサービス）  

## 解決する課題
1. **テキストパースの不安定性**  
   - 自然言語出力を正規表現や NLP で解析するとフォーマット崩れや例外パターンが増える  
2. **コードの複雑化**  
   - 手作業でパースロジックを大量に書くとバグとメンテナンスコストが激増  
3. **型安全・バリデーション不足**  
   - 受信後に不正な値や欠損が混入しても検知が難しい  

## 対象とするシステム／プロジェクト
- **マイクロサービスアーキテクチャ**：LLM 呼び出しサービスが他サービスへ JSON 形式でデータを返却  
- **ETL／データパイプライン**：大量文書から構造化データを抽出し、DB／データレイクへ投入  
- **チャットボット基盤**：ユーザ回答をアンケート形式で受け取り、即時集計・可視化  
- **エンタープライズレポート**：定型レポートの数値項目を直接 JSON 化して BI ツール連携  

## 利用するメリット
- **高い信頼性**：パーサー側でスキーマ違反を即検出しエラー処理可能  
- **開発効率向上**：手動パースコードの大幅削減、すぐに型付きデータとして利用  
- **セキュリティ強化**：予期しないフィールドやコード注入のリスクを減少  
- **運用保守容易**：Schema Registry（スキーマ管理）とテストデータで品質ゲートを構築  

## 注意点とトレードオフ
- **モデル依存性**  
  - Function Calling や JSON Mode 非対応のモデルでは運用できない  
- **創造的応答の制限**  
  - 自由な文章生成よりスキーマ厳守を優先するため、表現の豊かさが犠牲に  
- **スキーマメンテナンスコスト**  
  - 要件変更に伴うスキーマ定義更新と、それに合ったプロンプトの調整が必要  
- **バージョン管理**  
  - スキーマのバージョンアップ時にデプロイ順序や後方互換性を管理  

## 導入のヒント
1. **小さなスキーマから開始**  
   - まずは JSON オブジェクトに必須フィールド 2～3 個の出力を強制し、動作を確認  
2. **Schema Registry の活用**  
   - スキーマ定義を中央リポジトリ（Git + CI バリデーション）で管理  
3. **テストデータ整備**  
   - 正常系／異常系の JSON サンプルを用意し、スキーマバリデーションを CI に組み込む  
4. **フェールセーフ設計**  
   - バリデーションエラー時はフォールバック処理（元のテキスト解析 or デフォルト値）を実装  
5. **プロンプト文書化**  
   - プロンプト内にスキーマ定義例をコメント記載し、保守担当者がすぐ参照できるようにする  
