# Retry with Adaptive Back-off Pattern

## 説明
Retry with Adaptive Back-off Pattern は、LLM API 呼び出し時に一時的な失敗（ネットワークエラー、レート制限、503 エラーなど）が発生した場合、即座に再試行するのではなく「指数関数的に増加する待機時間」＋「ランダムなジッター」を組み合わせて再試行を行うレジリエンス手法です。呼び出しが継続的に失敗する状況下でも、適切に待機間隔を伸ばすことでサービス全体への負荷を抑えつつ、最終的に成功を狙います。

## 用途
- **マイクロサービス／API ゲートウェイ**：下流の LLM サービスが一時的に過負荷となったときに全体の吞み込みを回避  
- **チャットボット／会話システム**：ユーザ対話中の短時間エラーで会話を中断せず、裏で再試行  
- **バッチ処理ジョブ**：大量ドキュメントを LLM で処理する際のスロットリングとして  
- **CLI／スクリプト実行**：コマンドラインからの一括推論で途中エラーが出ても止めずに完遂  

## 解決する課題
1. **瞬間的レート制限エラー**  
   - 同時リクエスト数が多いと 429 エラーで全リクエストが弾かれやすい  
2. **ネットワークの一時的トラブル**  
   - パケットロスやコネクション不安定時の短期的なタイムアウト  
3. **スパイク負荷による下流サービス圧迫**  
   - 再試行が同時発生すると「雨あられ」的に負荷が集中  
4. **無制限なリトライによるリソース枯渇**  
   - 無限ループでリクエストを投げ続け、システム全体を停止させるリスク  

## 対象とするシステム／プロジェクト
- **SaaS マイクロサービス**：複数テナントから同時に呼び出される LLM API  
- **リアルタイム対話アプリ**：遅延にシビアなユーザインタフェースを持つチャットボット  
- **バッチ ETL パイプライン**：数千〜数万件の文書を一括で要約・分類するバッチ処理  
- **分散バッチ実行フレームワーク**：Spark や Airflow などから呼び出される LLM タスク  

## 利用するメリット
- **高いレジリエンス**：一時エラーを自動回復し、ユーザ体験を中断させない  
- **API への優しい負荷分散**：指数的バック-off が呼び出しの集中を緩和  
- **自動スロットリング**：手動調整なしで再試行間隔を変化させ、ピーク負荷時も安定  
- **一貫した実装**：共通ライブラリ化することで全サービスで同じ再試行戦略を適用  

## 注意点とトレードオフ
- **増大するレイテンシ**  
  - 再試行回数 × バック-off間隔分だけ最終応答が遅れる  
- **設定パラメータの複雑性**  
  - 初期待機時間、最大待機時間、ジッター幅、最大リトライ回数など多数のチューニング値  
- **バック-offパターンの選定**  
  - 指数関数的 vs 線形 vs カスタム。誤った選択でかえって負荷集中を招く  
- **可観測性不足**  
  - 再試行回数や成功率を計測／可視化しないと、問題の根本原因が見えにくい  

## 導入のヒント
1. **ライブラリ利用から開始**  
   - Resilience4j（Java）、Polly（.NET）、retry-or-not（Python）など既存ライブラリを活用  
2. **Jitter を必ず組み込む**  
   - 完全な指数 back-off では同期リトライが起きやすいため、小さな乱数を加える  
3. **メトリクス収集**  
   - 再試行回数、バック-off 時間分布、最終成功率をダッシュボードに出力  
4. **段階的チューニング**  
   - 小規模負荷→中規模負荷→ピーク負荷とステージング環境で順次パラメータ調整  
5. **フォールバック連携**  
   - 再試行上限を超えたら Timeout & Fallback Pattern と組み合わせ、代替処理へ切り替え  
