# Inverted Structured Output Pattern

## 説明
Inverted Structured Output Pattern は、LLM にダイナミックに “出力スキーマ” 自体を生成させ、そのスキーマ定義（例：Pydantic クラス、JSON Schema、Protobuf 定義）をもとに構造化されたデータを返却させる手法です。  
- **メタプログラミング**：モデルに「あなたの出力は以下のデータ構造に従うべし」と指示し、その構造を出力してもらう  
- **動的クラス生成**：受け取ったスキーマ定義をランタイムでクラス化（例：`pydantic.BaseModel` を動的生成）し、そのモデルで後続データをパース・検証  

## 用途
- **プラグイン／エージェント開発**：未知のツールやドメインに対応する API パラメータ構造を LLM 自身に定義させる  
- **汎用ワークフローエンジン**：利用者が柔軟に定義するデータ構造を事前に固定せず、動的に取り込む  
- **RAG エンジニアリング**：リトリーバルしたドメイン知識に基づき、応答ペイロード構造を LLM に設計させる  

## 解決する課題
1. **スキーマ前提の制約**  
   - 事前に全ての出力構造を開発者が定義できない場合に柔軟に対応  
2. **高い拡張性要求**  
   - エンドユーザや管理者が独自に出力形式を変更・拡張するニーズに追従  
3. **メンテナンス負荷**  
   - 頻繁に要件変化するデータ構造を、コード変更不要で取り込む  

## 対象とするシステム／プロジェクト
- **Auto-Agent プラットフォーム**：ツール呼び出しや API 定義を LLM が自律的に設計  
- **Low-Code／No-Code 環境**：ユーザの GUI 操作で生成されるスキーマをモデルに渡してコード化  
- **複雑データ統合サービス**：多種多様な入力形式を動的スキーマでハンドリング  

## 利用するメリット
- **究極の柔軟性**  
  - 事前定義レスで新規スキーマにも即対応  
- **迅速なプロトタイピング**  
  - 手動でクラス定義せずともデータモデルを即利用可能  
- **一貫した検証**  
  - LLM が返すスキーマで同時にバリデーションロジックも自動生成  

## 注意点とトレードオフ
- **モデル精度依存**  
  - スキーマ定義をモデルが誤生成すると、後続データパースが崩壊  
- **セキュリティリスク**  
  - 悪意あるスキーマ（無限再帰定義など）を生成される恐れ  
- **実行時オーバーヘッド**  
  - 動的クラス生成と検証処理でレイテンシやメモリを消費  
- **デバッグ困難**  
  - 自動生成スキーマのバグ原因を特定しづらい  

## 導入のヒント
1. **最初はサンプル限定**  
   - 限定的なフィールド構成（数フィールド＋単純型）で動作検証  
2. **スキーマ安全化**  
   - 出力スキーマを再度固定スキーマでラップし、許可リスト型チェックを行う  
3. **タイムアウト管理**  
   - スキーマ生成とパース処理に分割タイムアウトを設定  
4. **監査ログの記録**  
   - 生成スキーマとその変更履歴をログに記録し、後日レビュー可能に  
5. **段階的実装**  
   - まずは出力スキーマのみ取得 → 次に動的クラス化 → 最後にデータ本体パースのステップで導入  
