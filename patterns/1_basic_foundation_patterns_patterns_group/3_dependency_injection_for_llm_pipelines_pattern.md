# Dependency Injection for LLM Pipelines Pattern

## 説明
Dependency Injection for LLM Pipelines パターンは、LLM を用いた処理パイプライン（プロンプト構築 → モデル呼び出し → レスポンス解析 → 後処理）をコンポーネント（クライアント、プロンプトビルダー、ロガー、エラーハンドラなど）単位で分割し、実行時に必要なインスタンスを「注入（Injection）」して組み立てる設計手法です。  
- **DI コンテナ**（Spring, Guice, NestJS, .NET Core DI など）や **Factory／Provider** クラスを使って依存関係を明示化  
- 各ステップの実装はインターフェース（`IModelClient`、`IPromptBuilder`、`IResponseParser` など）を通じて抽象化

## 用途
- **大規模アプリケーション**：複数モジュールで LLM を再利用し、共通処理を横展開  
- **マイクロサービス**：各サービスが独自のプロンプト／モデルクライアントを持つが、共通インターフェースで運用  
- **プラグイン／エクステンション対応**：新機能（例：ツール呼び出し, カスタム解析コンポーネント）を既存パイプラインに容易に差し込む

## 解決する課題
1. **高い結合度**  
   - ビジネスロジックに直接 `new OpenAIClient()` や `new PromptBuilder()` を書くと、交換やテストが困難  
2. **テストの煩雑化**  
   - モデル呼び出しや後処理をスタブ化・モック化できず、ユニットテストがインテグレーションテスト化  
3. **コードの重複**  
   - 各クラスで同じ初期化コード（API キー設定、タイムアウト設定、メトリクス登録など）が散在  
4. **拡張性の欠如**  
   - 新たな処理フローやエラーハンドリングを追加するたびに既存コードを改修

## 対象とするシステム／プロジェクト
- **エンタープライズ向け SaaS プラットフォーム**：複数の LLM モジュールを横断的に管理  
- **API ゲートウェイ**：リクエストごとに異なるモデルクライアントやロギング／認証コンポーネントを注入  
- **社内共通ライブラリ**：Teams やプロダクト横断で再利用する LLM 呼び出し基盤  
- **CI/CD パイプライン**：環境（開発・ステージング・本番）ごとに異なる設定を注入してデプロイ

## 利用するメリット
- **疎結合**  
  - 実装交換やバージョンアップが容易（例：OpenAI → Anthropic 切替が設定のみで完結）  
- **テスト容易性**  
  - モック／フェイクコンポーネントを注入して、LLM 呼び出しを完全にスタブ化可能  
- **設定集中管理**  
  - API キーやエンドポイント、リトライ設定などをコンテナ設定ファイルで一元化  
- **再利用性**  
  - 汎用的なインターフェースを共有ライブラリとして切り出し、複数プロジェクトで活用  
- **拡張性**  
  - 新たなログ出力／メトリクス収集／トレーシング機能をパイプラインへプラグイン可能

## 注意点とトレードオフ
- **導入コスト**  
  - DI フレームワークの学習・初期設定が必要で、シンプルなプロジェクトでは過剰設計に  
- **実行時オーバーヘッド**  
  - コンテナによるリフレクションやプロキシ生成で若干のレイテンシ増加  
- **複雑度の増加**  
  - インターフェース／設定ファイル／モジュール定義が増え、初見の開発者には理解ハードルが上がる  
- **デバッグ難易度**  
  - 注入されたインスタンスのライフサイクル管理（スコープ、シングルトン vs トランジェント）に注意  

---

**導入のヒント**  
1. まずは「`IModelClient` + `IPromptBuilder`」という最小構成から DI を導入。  
2. 設定ファイルで環境ごと（dev/staging/prod）の実装バインディングを簡単切り替え。  
3. ロギング／メトリクス用の共通インターセプタを DI コンテナのパイプラインに組み込み、横断的な可観測性を確保。  
