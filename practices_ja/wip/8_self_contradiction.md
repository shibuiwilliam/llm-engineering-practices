# Self-contradiction Pattern

## 概要
Self-contradiction Patternは、ユーザの過去の入力に矛盾する内容が含まれていた場合でも、LLMの出力品質を維持するためのプロンプト履歴管理手法です。人間の発言や行動には文脈依存の変化や矛盾が含まれることが自然であり、LLMベースのアプリケーションではその取り扱いが品質に大きく影響します。

## 解決したい課題
LLMアプリケーションでは、ユーザの発話や操作履歴をプロンプト履歴としてコンテキストに利用するケースが一般的です。しかし、以下のような課題が発生します。

1. **履歴上の矛盾によってLLMが混乱する**
   - 例：ユーザが「ダイエット中の食事を教えて」と言った後に、「食べ過ぎた後のカロリー摂取量は？」と尋ねた場合、前後の一貫性がないように見え、LLMの出力が不安定になる可能性があります。

2. **会話の目的や時系列が明示されないまま履歴が流用される**
   - コンテキストウィンドウ内に含まれる過去の発話が、現在の質問と直接関係ない内容であっても、LLMがそれを重視してしまう可能性があります。

3. **ユーザの一貫性よりも時系列や文脈の変化が重要であるにもかかわらず、それが考慮されない**
   - ユーザが状況を変化させた結果の発言であることを明示できなければ、LLMが誤って前提を維持しようとして不適切な応答をすることがあります。

## 解決策
Self-contradiction Patternでは、履歴の時系列と文脈の切り替えを明示的に管理することで、LLMにとって必要な情報だけを適切な形でプロンプトとして提供します。具体的な対策は以下の通りです。

1. **セッションの文脈区切りを導入する**
   - 「新しい話題」や「状況が変わった」ことを検出し、内部的にセッションを切り替えることで履歴のスコープを明示します。
   - 例：「ここからは別の質問です」などの明示的な発話や時間の経過をトリガーに使用します。

2. **履歴のスコープを制限する**
   - 最新の数ターンや、現在のトピックに関係のある履歴のみに絞ってLLMに渡すことで、古い矛盾する履歴の影響を減らします。

3. **メタ情報を付与して履歴を管理する**
   - 各発言に対して「トピック」「発話意図」「信頼度」「一時的な発言かどうか」などの属性を付与し、プロンプトに渡す際に取捨選択を制御します。

4. **矛盾検出とフィルタリング**
   - LLMにより過去の履歴同士を自己チェックし、明らかな矛盾を含む発言をプロンプトから除外したり、注釈を付けてLLMに提示します。

## 適応するシーン
- ユーザが繰り返し利用するChatbotやAIエージェント
- セッションの長さが長く、履歴が多岐にわたるシステム
- カスタマーサポート、ヘルスケア、教育など、文脈の変化が頻繁に発生する対話型アプリケーション

## 利用するメリット
- 履歴によるLLMの出力劣化を防ぎ、安定した回答品質を保てます。
- ユーザの柔軟な発言や行動変化を自然に扱えるため、ユーザ体験が向上します。
- 長期利用時の文脈管理・履歴整合性の問題を軽減できます。

## 注意点とトレードオフ
- 履歴管理と矛盾検出のロジックが複雑化する可能性があります。
- LLMが履歴の整合性をどの程度重視するかはモデル依存のため、過剰な調整が逆効果になる場合もあります。
- セッション区切りや文脈ラベルの自動化には追加の自然言語処理が必要になります。

## 導入のヒント
- 履歴に対するTTL（Time to Live）を設定し、古い履歴は自然に破棄される仕組みにすると導入しやすくなります。
- 文脈ラベル付けやトピック検出は、LLM自身に要約・分類させることで自動化できます。
- 小規模なPoCでは明示的な「文脈リセット」ボタンをUIに設けるだけでも十分に効果があります。

## まとめ
Self-contradiction Patternは、LLMの出力に悪影響を与える矛盾した履歴を制御・管理するための設計パターンです。ユーザの自然な行動変化を尊重しながら、プロンプトの文脈整合性を確保することで、LLMアプリケーションの品質と信頼性を高めることができます。